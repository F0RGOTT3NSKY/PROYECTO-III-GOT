\begin{quote}
Wrap native H\+T\+TP requests with R\+FC compliant cache support \end{quote}


\href{https://travis-ci.org/lukechilds/cacheable-request}{\texttt{ }} \href{https://coveralls.io/github/lukechilds/cacheable-request?branch=master}{\texttt{ }} \href{https://www.npmjs.com/package/cacheable-request}{\texttt{ }} \href{https://www.npmjs.com/package/cacheable-request}{\texttt{ }}

\href{http://httpwg.org/specs/rfc7234.html}{\texttt{ R\+FC 7234}} compliant H\+T\+TP caching for native Node.\+js H\+T\+T\+P/\+H\+T\+T\+PS requests. Caching works out of the box in memory or is easily pluggable with a wide range of storage adapters.

{\bfseries{Note\+:}} This is a low level wrapper around the core H\+T\+TP modules, it\textquotesingle{}s not a high level request library.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md523}{}\doxysection{Features}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md523}

\begin{DoxyItemize}
\item Only stores cacheable responses as defined by R\+FC 7234
\item Fresh cache entries are served directly from cache
\item Stale cache entries are revalidated with {\ttfamily If-\/\+None-\/\+Match}/{\ttfamily If-\/\+Modified-\/\+Since} headers
\item 304 responses from revalidation requests use cached body
\item Updates {\ttfamily Age} header on cached responses
\item Can completely bypass cache on a per request basis
\item In memory cache by default
\item Official support for Redis, Mongo\+DB, S\+Q\+Lite, Postgre\+S\+QL and My\+S\+QL storage adapters
\item Easily plug in your own or third-\/party storage adapters
\item If DB connection fails, cache is automatically bypassed (\href{\#optsautomaticfailover}{\texttt{ disabled by default}})
\item Adds cache support to any existing H\+T\+TP code with minimal changes
\item Uses \href{https://github.com/pornel/http-cache-semantics}{\texttt{ http-\/cache-\/semantics}} internally for H\+T\+TP R\+FC 7234 compliance
\end{DoxyItemize}\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md524}{}\doxysection{Install}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md524}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm install cacheable-\/request}
\end{DoxyCode}
\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md525}{}\doxysection{Usage}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md525}

\begin{DoxyCode}{0}
\DoxyCodeLine{const http = require('http');}
\DoxyCodeLine{const CacheableRequest = require('cacheable-\/request');}
\DoxyCodeLine{}
\DoxyCodeLine{// Then instead of}
\DoxyCodeLine{const req = http.request('http://example.com', cb);}
\DoxyCodeLine{req.end();}
\DoxyCodeLine{}
\DoxyCodeLine{// You can do}
\DoxyCodeLine{const cacheableRequest = new CacheableRequest(http.request);}
\DoxyCodeLine{const cacheReq = cacheableRequest('http://example.com', cb);}
\DoxyCodeLine{cacheReq.on('request', req => req.end());}
\DoxyCodeLine{// Future requests to 'example.com' will be returned from cache if still valid}
\DoxyCodeLine{}
\DoxyCodeLine{// You pass in any other http.request API compatible method to be wrapped with cache support:}
\DoxyCodeLine{const cacheableRequest = new CacheableRequest(https.request);}
\DoxyCodeLine{const cacheableRequest = new CacheableRequest(electron.net);}
\end{DoxyCode}
\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md526}{}\doxysection{Storage Adapters}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md526}
{\ttfamily cacheable-\/request} uses \href{https://github.com/lukechilds/keyv}{\texttt{ Keyv}} to support a wide range of storage adapters.

For example, to use Redis as a cache backend, you just need to install the official Redis Keyv storage adapter\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{npm install @keyv/redis}
\end{DoxyCode}


And then you can pass {\ttfamily Cacheable\+Request} your connection string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const cacheableRequest = new CacheableRequest(http.request, 'redis://user:pass@localhost:6379');}
\end{DoxyCode}


\href{https://github.com/lukechilds/keyv\#official-storage-adapters}{\texttt{ View all official Keyv storage adapters.}}

Keyv also supports anything that follows the Map A\+PI so it\textquotesingle{}s easy to write your own storage adapter or use a third-\/party solution.

e.\+g The following are all valid storage adapters


\begin{DoxyCode}{0}
\DoxyCodeLine{const storageAdapter = new Map();}
\DoxyCodeLine{// or}
\DoxyCodeLine{const storageAdapter = require('./my-\/storage-\/adapter');}
\DoxyCodeLine{// or}
\DoxyCodeLine{const QuickLRU = require('quick-\/lru');}
\DoxyCodeLine{const storageAdapter = new QuickLRU(\{ maxSize: 1000 \});}
\DoxyCodeLine{}
\DoxyCodeLine{const cacheableRequest = new CacheableRequest(http.request, storageAdapter);}
\end{DoxyCode}


View the \href{https://github.com/lukechilds/keyv}{\texttt{ Keyv docs}} for more information on how to use storage adapters.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md527}{}\doxysection{A\+PI}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md527}
\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md528}{}\doxysubsection{new cacheable\+Request(request, \mbox{[}storage\+Adapter\mbox{]})}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md528}
Returns the provided request function wrapped with cache support.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md529}{}\doxysubsubsection{request}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md529}
Type\+: {\ttfamily function}

Request function to wrap with cache support. Should be \href{https://nodejs.org/api/http.html\#http_http_request_options_callback}{\texttt{ {\ttfamily http.\+request}}} or a similar A\+PI compatible request function.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md530}{}\doxysubsubsection{storage\+Adapter}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md530}
Type\+: {\ttfamily Keyv storage adapter}~\newline
 Default\+: {\ttfamily new Map()}

A \href{https://github.com/lukechilds/keyv}{\texttt{ Keyv}} storage adapter instance, or connection string if using with an official Keyv storage adapter.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md531}{}\doxysubsection{Instance}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md531}
\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md532}{}\doxysubsubsection{cacheable\+Request(opts, \mbox{[}cb\mbox{]})}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md532}
Returns an event emitter.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md533}{}\doxyparagraph{opts}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md533}
Type\+: {\ttfamily object}, {\ttfamily string}


\begin{DoxyItemize}
\item Any of the default request functions options.
\item Any \href{https://github.com/kornelski/http-cache-semantics\#constructor-options}{\texttt{ {\ttfamily http-\/cache-\/semantics}}} options.
\item Any of the following\+:
\end{DoxyItemize}

\doxysubparagraph*{opts.\+cache}

Type\+: {\ttfamily boolean}~\newline
 Default\+: {\ttfamily true}

If the cache should be used. Setting this to false will completely bypass the cache for the current request.

\doxysubparagraph*{opts.\+strict\+Ttl}

Type\+: {\ttfamily boolean}~\newline
 Default\+: {\ttfamily false}

If set to {\ttfamily true} once a cached resource has expired it is deleted and will have to be re-\/requested.

If set to {\ttfamily false} (default), after a cached resource\textquotesingle{}s T\+TL expires it is kept in the cache and will be revalidated on the next request with {\ttfamily If-\/\+None-\/\+Match}/{\ttfamily If-\/\+Modified-\/\+Since} headers.

\doxysubparagraph*{opts.\+max\+Ttl}

Type\+: {\ttfamily number}~\newline
 Default\+: {\ttfamily undefined}

Limits T\+TL. The {\ttfamily number} represents milliseconds.

\doxysubparagraph*{opts.\+automatic\+Failover}

Type\+: {\ttfamily boolean}~\newline
 Default\+: {\ttfamily false}

When set to {\ttfamily true}, if the DB connection fails we will automatically fallback to a network request. DB errors will still be emitted to notify you of the problem even though the request callback may succeed.

\doxysubparagraph*{opts.\+force\+Refresh}

Type\+: {\ttfamily boolean}~\newline
 Default\+: {\ttfamily false}

Forces refreshing the cache. If the response could be retrieved from the cache, it will perform a new request and override the cache instead.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md534}{}\doxyparagraph{cb}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md534}
Type\+: {\ttfamily function}

The callback function which will receive the response as an argument.

The response can be either a \href{https://nodejs.org/api/http.html\#http_class_http_incomingmessage}{\texttt{ Node.\+js H\+T\+TP response stream}} or a \href{https://github.com/lukechilds/responselike}{\texttt{ responselike object}}. The response will also have a {\ttfamily from\+Cache} property set with a boolean value.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md535}{}\doxyparagraph{.\+on(\textquotesingle{}request\textquotesingle{}, request)}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md535}
{\ttfamily request} event to get the request object of the request.

{\bfseries{Note\+:}} This event will only fire if an H\+T\+TP request is actually made, not when a response is retrieved from cache. However, you should always handle the {\ttfamily request} event to end the request and handle any potential request errors.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md536}{}\doxyparagraph{.\+on(\textquotesingle{}response\textquotesingle{}, response)}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md536}
{\ttfamily response} event to get the response object from the H\+T\+TP request or cache.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md537}{}\doxyparagraph{.\+on(\textquotesingle{}error\textquotesingle{}, error)}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md537}
{\ttfamily error} event emitted in case of an error with the cache.

Errors emitted here will be an instance of {\ttfamily Cacheable\+Request.\+Request\+Error} or {\ttfamily Cacheable\+Request.\+Cache\+Error}. You will only ever receive a {\ttfamily Request\+Error} if the request function throws (normally caused by invalid user input). Normal request errors should be handled inside the {\ttfamily request} event.

To properly handle all error scenarios you should use the following pattern\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{cacheableRequest('example.com', cb)}
\DoxyCodeLine{  .on('error', err => \{}
\DoxyCodeLine{    if (err instanceof CacheableRequest.CacheError) \{}
\DoxyCodeLine{      handleCacheError(err); // Cache error}
\DoxyCodeLine{    \} else if (err instanceof CacheableRequest.RequestError) \{}
\DoxyCodeLine{      handleRequestError(err); // Request function thrown}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \})}
\DoxyCodeLine{  .on('request', req => \{}
\DoxyCodeLine{    req.on('error', handleRequestError); // Request error emitted}
\DoxyCodeLine{    req.end();}
\DoxyCodeLine{  \});}
\end{DoxyCode}


{\bfseries{Note\+:}} Database connection errors are emitted here, however {\ttfamily cacheable-\/request} will attempt to re-\/request the resource and bypass the cache on a connection error. Therefore a database connection error doesn\textquotesingle{}t necessarily mean the request won\textquotesingle{}t be fulfilled.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md538}{}\doxysection{License}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api_node_modules_cacheable-request__r_e_a_d_m_e_autotoc_md538}
M\+IT Â© Luke Childs 