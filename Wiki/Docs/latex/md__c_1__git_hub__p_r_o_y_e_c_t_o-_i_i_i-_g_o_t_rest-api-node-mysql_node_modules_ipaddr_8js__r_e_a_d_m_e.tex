ipaddr.\+js is a small (1.\+9K minified and gzipped) library for manipulating IP addresses in Java\+Script environments. It runs on both Common\+JS runtimes (e.\+g. \href{http://nodejs.org}{\texttt{ nodejs}}) and in a web browser.

ipaddr.\+js allows you to verify and parse string representation of an IP address, match it against a C\+I\+DR range or range list, determine if it falls into some reserved ranges (examples include loopback and private ranges), and convert between I\+Pv4 and I\+Pv4-\/mapped I\+Pv6 addresses.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4989}{}\doxysection{Installation}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4989}
{\ttfamily npm install ipaddr.\+js}

or

{\ttfamily bower install ipaddr.\+js}\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4990}{}\doxysection{A\+PI}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4990}
ipaddr.\+js defines one object in the global scope\+: {\ttfamily ipaddr}. In Common\+JS, it is exported from the module\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var ipaddr = require('ipaddr.js');}
\end{DoxyCode}


The A\+PI consists of several global methods and two classes\+: ipaddr.\+I\+Pv6 and ipaddr.\+I\+Pv4.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4991}{}\doxysubsection{Global methods}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4991}
There are three global methods defined\+: {\ttfamily ipaddr.\+is\+Valid}, {\ttfamily ipaddr.\+parse} and {\ttfamily ipaddr.\+process}. All of them receive a string as a single parameter.

The {\ttfamily ipaddr.\+is\+Valid} method returns {\ttfamily true} if the address is a valid I\+Pv4 or I\+Pv6 address, and {\ttfamily false} otherwise. It does not throw any exceptions.

The {\ttfamily ipaddr.\+parse} method returns an object representing the IP address, or throws an {\ttfamily Error} if the passed string is not a valid representation of an IP address.

The {\ttfamily ipaddr.\+process} method works just like the {\ttfamily ipaddr.\+parse} one, but it automatically converts I\+Pv4-\/mapped I\+Pv6 addresses to their I\+Pv4 counterparts before returning. It is useful when you have a Node.\+js instance listening on an I\+Pv6 socket, and the {\ttfamily net.\+ivp6.\+bindv6only} sysctl parameter (or its equivalent on non-\/\+Linux OS) is set to 0. In this case, you can accept I\+Pv4 connections on your I\+Pv6-\/only socket, but the remote address will be mangled. Use {\ttfamily ipaddr.\+process} method to automatically demangle it.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4992}{}\doxysubsection{Object representation}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4992}
Parsing methods return an object which descends from {\ttfamily ipaddr.\+I\+Pv6} or {\ttfamily ipaddr.\+I\+Pv4}. These objects share some properties, but most of them differ.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4993}{}\doxysubsubsection{Shared properties}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4993}
One can determine the type of address by calling {\ttfamily addr.\+kind()}. It will return either {\ttfamily \char`\"{}ipv6\char`\"{}} or {\ttfamily \char`\"{}ipv4\char`\"{}}.

An address can be converted back to its string representation with {\ttfamily addr.\+to\+String()}. Note that this method\+:
\begin{DoxyItemize}
\item does not return the original string used to create the object (in fact, there is no way of getting that string)
\item returns a compact representation (when it is applicable)
\end{DoxyItemize}

A {\ttfamily match(range, bits)} method can be used to check if the address falls into a certain C\+I\+DR range. Note that an address can be (obviously) matched only against an address of the same type.

For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var addr = ipaddr.parse("2001:db8:1234::1");}
\DoxyCodeLine{var range = ipaddr.parse("2001:db8::");}
\DoxyCodeLine{}
\DoxyCodeLine{addr.match(range, 32); // => true}
\end{DoxyCode}


Alternatively, {\ttfamily match} can also be called as {\ttfamily match(\mbox{[}range, bits\mbox{]})}. In this way, it can be used together with the {\ttfamily parse\+C\+I\+D\+R(string)} method, which parses an IP address together with a C\+I\+DR range.

For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var addr = ipaddr.parse("2001:db8:1234::1");}
\DoxyCodeLine{}
\DoxyCodeLine{addr.match(ipaddr.parseCIDR("2001:db8::/32")); // => true}
\end{DoxyCode}


A {\ttfamily range()} method returns one of predefined names for several special ranges defined by IP protocols. The exact names (and their respective C\+I\+DR ranges) can be looked up in the source\+: \href{https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee\#L186}{\texttt{ I\+Pv6 ranges}} and \href{https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee\#L71}{\texttt{ I\+Pv4 ranges}}. Some common ones include {\ttfamily \char`\"{}unicast\char`\"{}} (the default one) and {\ttfamily \char`\"{}reserved\char`\"{}}.

You can match against your own range list by using {\ttfamily ipaddr.\+subnet\+Match(address, range\+List, default\+Name)} method. It can work with a mix of I\+Pv6 or I\+Pv4 addresses, and accepts a name-\/to-\/subnet map as the range list. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var rangeList = \{}
\DoxyCodeLine{  documentationOnly: [ ipaddr.parse('2001:db8::'), 32 ],}
\DoxyCodeLine{  tunnelProviders: [}
\DoxyCodeLine{    [ ipaddr.parse('2001:470::'), 32 ], // he.net}
\DoxyCodeLine{    [ ipaddr.parse('2001:5c0::'), 32 ]  // freenet6}
\DoxyCodeLine{  ]}
\DoxyCodeLine{\};}
\DoxyCodeLine{ipaddr.subnetMatch(ipaddr.parse('2001:470:8:66::1'), rangeList, 'unknown'); // => "tunnelProviders"}
\end{DoxyCode}


The addresses can be converted to their byte representation with {\ttfamily to\+Byte\+Array()}. (Actually, Java\+Script mostly does not know about byte buffers. They are emulated with arrays of numbers, each in range of 0..255.)


\begin{DoxyCode}{0}
\DoxyCodeLine{var bytes = ipaddr.parse('2a00:1450:8007::68').toByteArray(); // ipv6.google.com}
\DoxyCodeLine{bytes // => [42, 0x00, 0x14, 0x50, 0x80, 0x07, 0x00, <zeroes...>, 0x00, 0x68 ]}
\end{DoxyCode}


The {\ttfamily ipaddr.\+I\+Pv4} and {\ttfamily ipaddr.\+I\+Pv6} objects have some methods defined, too. All of them have the same interface for both protocols, and are similar to global methods.

{\ttfamily ipaddr.\+I\+Pv\+X.\+is\+Valid(string)} can be used to check if the string is a valid address for particular protocol, and {\ttfamily ipaddr.\+I\+Pv\+X.\+parse(string)} is the error-\/throwing parser.

{\ttfamily ipaddr.\+I\+Pv\+X.\+is\+Valid(string)} uses the same format for parsing as the P\+O\+S\+IX {\ttfamily inet\+\_\+ntoa} function, which accepts unusual formats like {\ttfamily 0xc0.\+168.\+1.\+1} or {\ttfamily 0x10000000}. The function {\ttfamily ipaddr.\+I\+Pv4.\+is\+Valid\+Four\+Part\+Decimal(string)} validates the I\+Pv4 address and also ensures that it is written in four-\/part decimal format.\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4994}{}\doxysubsubsection{I\+Pv6 properties}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4994}
Sometimes you will want to convert I\+Pv6 not to a compact string representation (with the {\ttfamily \+::} substitution); the {\ttfamily to\+Normalized\+String()} method will return an address where all zeroes are explicit.

For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var addr = ipaddr.parse("2001:0db8::0001");}
\DoxyCodeLine{addr.toString(); // => "2001:db8::1"}
\DoxyCodeLine{addr.toNormalizedString(); // => "2001:db8:0:0:0:0:0:1"}
\end{DoxyCode}


The {\ttfamily is\+I\+Pv4\+Mapped\+Address()} method will return {\ttfamily true} if this address is an I\+Pv4-\/mapped one, and {\ttfamily to\+I\+Pv4\+Address()} will return an I\+Pv4 object address.

To access the underlying binary representation of the address, use {\ttfamily addr.\+parts}.


\begin{DoxyCode}{0}
\DoxyCodeLine{var addr = ipaddr.parse("2001:db8:10::1234:DEAD");}
\DoxyCodeLine{addr.parts // => [0x2001, 0xdb8, 0x10, 0, 0, 0, 0x1234, 0xdead]}
\end{DoxyCode}


A I\+Pv6 zone index can be accessed via {\ttfamily addr.\+zone\+Id}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var addr = ipaddr.parse("2001:db8::\%eth0");}
\DoxyCodeLine{addr.zoneId // => 'eth0'}
\end{DoxyCode}
\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4995}{}\doxysubsubsection{I\+Pv4 properties}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4995}
{\ttfamily to\+I\+Pv4\+Mapped\+Address()} will return a corresponding I\+Pv4-\/mapped I\+Pv6 address.

To access the underlying representation of the address, use {\ttfamily addr.\+octets}.


\begin{DoxyCode}{0}
\DoxyCodeLine{var addr = ipaddr.parse("192.168.1.1");}
\DoxyCodeLine{addr.octets // => [192, 168, 1, 1]}
\end{DoxyCode}


{\ttfamily prefix\+Length\+From\+Subnet\+Mask()} will return a C\+I\+DR prefix length for a valid I\+Pv4 netmask or null if the netmask is not valid.


\begin{DoxyCode}{0}
\DoxyCodeLine{ipaddr.IPv4.parse('255.255.255.240').prefixLengthFromSubnetMask() == 28}
\DoxyCodeLine{ipaddr.IPv4.parse('255.192.164.0').prefixLengthFromSubnetMask()  == null}
\end{DoxyCode}


{\ttfamily subnet\+Mask\+From\+Prefix\+Length()} will return an I\+Pv4 netmask for a valid C\+I\+DR prefix length.


\begin{DoxyCode}{0}
\DoxyCodeLine{ipaddr.IPv4.subnetMaskFromPrefixLength(24) == "255.255.255.0"}
\DoxyCodeLine{ipaddr.IPv4.subnetMaskFromPrefixLength(29) == "255.255.255.248"}
\end{DoxyCode}


{\ttfamily broadcast\+Address\+From\+C\+I\+D\+R()} will return the broadcast address for a given I\+Pv4 interface and netmask in C\+I\+DR notation. 
\begin{DoxyCode}{0}
\DoxyCodeLine{ipaddr.IPv4.broadcastAddressFromCIDR("172.0.0.1/24") == "172.0.0.255"}
\end{DoxyCode}


{\ttfamily network\+Address\+From\+C\+I\+D\+R()} will return the network address for a given I\+Pv4 interface and netmask in C\+I\+DR notation. 
\begin{DoxyCode}{0}
\DoxyCodeLine{ipaddr.IPv4.networkAddressFromCIDR("172.0.0.1/24") == "172.0.0.0"}
\end{DoxyCode}
\hypertarget{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4996}{}\doxysubsubsection{Conversion}\label{md__c_1__git_hub__p_r_o_y_e_c_t_o-_i_i_i-_g_o_t_rest-api-node-mysql_node_modules_ipaddr_8js__r_e_a_d_m_e_autotoc_md4996}
I\+Pv4 and I\+Pv6 can be converted bidirectionally to and from network byte order (M\+SB) byte arrays.

The {\ttfamily from\+Byte\+Array()} method will take an array and create an appropriate I\+Pv4 or I\+Pv6 object if the input satisfies the requirements. For I\+Pv4 it has to be an array of four 8-\/bit values, while for I\+Pv6 it has to be an array of sixteen 8-\/bit values.

For example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var addr = ipaddr.fromByteArray([0x7f, 0, 0, 1]);}
\DoxyCodeLine{addr.toString(); // => "127.0.0.1"}
\end{DoxyCode}


or


\begin{DoxyCode}{0}
\DoxyCodeLine{var addr = ipaddr.fromByteArray([0x20, 1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])}
\DoxyCodeLine{addr.toString(); // => "2001:db8::1"}
\end{DoxyCode}


Both objects also offer a {\ttfamily to\+Byte\+Array()} method, which returns an array in network byte order (M\+SB).

For example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var addr = ipaddr.parse("127.0.0.1");}
\DoxyCodeLine{addr.toByteArray(); // => [0x7f, 0, 0, 1]}
\end{DoxyCode}


or


\begin{DoxyCode}{0}
\DoxyCodeLine{var addr = ipaddr.parse("2001:db8::1");}
\DoxyCodeLine{addr.toByteArray(); // => [0x20, 1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
\end{DoxyCode}
 